{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome AICafe is a Python package built to interact with iCafe. It implements the entire workflow of iCafe for intracranial vascular analysis:","title":"Welcome"},{"location":"#welcome","text":"AICafe is a Python package built to interact with iCafe. It implements the entire workflow of iCafe for intracranial vascular analysis:","title":"Welcome"},{"location":"APIs/","text":"Introduction This is the introduction of APIs.","title":"Introduction"},{"location":"APIs/#introduction","text":"This is the introduction of APIs.","title":"Introduction"},{"location":"APIs/aicafe.definitions/","text":"module aicafe.definitions The definitions of some constants. Examples: You can access those constants by: >>> from aicafe import definitions as defn >>> defn . TYPES_TIFS_REGULAR [ 'o' , 'v' , 's' , 'b' , 'i' , 'n' , 's.whole' ] N_TYPES_SNAKES = 25 The number of snake types. TYPES_SEQUENCES = list ( chain . from_iterable ([[ 'S {x} ' , 'S {x} _ori' ] for x in range ( 100 , 110 )])) List of types of tif files of sequences. Currently, it is [ 'S100' , 'S100_ori' , ... , 'S109' , 'S109_ori' ] . TYPES_SNAKES = [ 'unknown' , 'ICA_L' , 'ICA_R' , 'M1_L' , 'M1_R' , 'M2_L' , 'M2_R' , 'A1_L' , 'A1_R' , 'A2_L' , 'A2_R' , 'AComm' , 'M3_L' , 'M3_R' , 'VA_L' , 'VA_R' , 'BA' , 'P1_L' , 'P1_R' , 'P2_L' , 'P2_R' , 'PComm_L' , 'PComm_R' , 'OA_L' , 'OA_R' ] List of snake types, with length equal to N_TYPES_SNAKES . Examples: You can use an integer index to access a snake type, e.g., >>> from aicafe import definitions as defn >>> defn . TYPES_SNAKES [ 3 ] 'M1_L' The correspondence between index and type index type index type index type 0 'unknown' 9 'A2_L' 17 'P1_L' 1 'ICA_L' 10 'A2_R' 18 'P1_R' 2 'ICA_R' 11 'AComm' 19 'P2_L' 3 'M1_L' 12 'M3_L' 20 'P2_R' 4 'M1_R' 13 'M3_R' 21 'PComm_L' 5 'M2_L' 14 'VA_L' 22 'PComm_R' 6 'M2_R' 15 'VA_R' 23 'OA_L' 7 'A1_L' 16 'BA' 24 'OA_R' 8 'A1_R' TYPES_TIFS = TYPES_TIFS_REGULAR + TYPES_SEQUENCES List of types of all tif files, a sum of TYPES_TIFS_REGULAR and TYPES_SEQUENCES . TYPES_TIFS_REGULAR = [ 'o' , 'v' , 's' , 'b' , 'i' , 'n' , 's.whole' ] List of types of regular tif files that may appear in a case folder. Currently, it is [ 'o' , 'v' , 's' , 'b' , 'i' , 'n' , 's.whole' ] .","title":"aicafe.definitions"},{"location":"APIs/aicafe.definitions/#aicafe.definitions","text":"The definitions of some constants. Examples: You can access those constants by: >>> from aicafe import definitions as defn >>> defn . TYPES_TIFS_REGULAR [ 'o' , 'v' , 's' , 'b' , 'i' , 'n' , 's.whole' ]","title":"definitions"},{"location":"APIs/aicafe.definitions/#aicafe.core.definitions.N_TYPES_SNAKES","text":"The number of snake types.","title":"N_TYPES_SNAKES"},{"location":"APIs/aicafe.definitions/#aicafe.core.definitions.TYPES_SEQUENCES","text":"List of types of tif files of sequences. Currently, it is [ 'S100' , 'S100_ori' , ... , 'S109' , 'S109_ori' ] .","title":"TYPES_SEQUENCES"},{"location":"APIs/aicafe.definitions/#aicafe.core.definitions.TYPES_SNAKES","text":"List of snake types, with length equal to N_TYPES_SNAKES . Examples: You can use an integer index to access a snake type, e.g., >>> from aicafe import definitions as defn >>> defn . TYPES_SNAKES [ 3 ] 'M1_L' The correspondence between index and type index type index type index type 0 'unknown' 9 'A2_L' 17 'P1_L' 1 'ICA_L' 10 'A2_R' 18 'P1_R' 2 'ICA_R' 11 'AComm' 19 'P2_L' 3 'M1_L' 12 'M3_L' 20 'P2_R' 4 'M1_R' 13 'M3_R' 21 'PComm_L' 5 'M2_L' 14 'VA_L' 22 'PComm_R' 6 'M2_R' 15 'VA_R' 23 'OA_L' 7 'A1_L' 16 'BA' 24 'OA_R' 8 'A1_R'","title":"TYPES_SNAKES"},{"location":"APIs/aicafe.definitions/#aicafe.core.definitions.TYPES_TIFS","text":"List of types of all tif files, a sum of TYPES_TIFS_REGULAR and TYPES_SEQUENCES .","title":"TYPES_TIFS"},{"location":"APIs/aicafe.definitions/#aicafe.core.definitions.TYPES_TIFS_REGULAR","text":"List of types of regular tif files that may appear in a case folder. Currently, it is [ 'o' , 'v' , 's' , 'b' , 'i' , 'n' , 's.whole' ] .","title":"TYPES_TIFS_REGULAR"},{"location":"APIs/aicafe.file/","text":"module aicafe.file This module contains functions for file operations. types_tifs_avail ( path_case ) Return a list of the types of available . tif files. Parameters: Name Type Description Default path_case str The path of the case whose available tifs need to be listed. required Returns: Name Type Description list list [ str ] A list of types. All types can be found in TYPES_TIFS .","title":"aicafe.file"},{"location":"APIs/aicafe.file/#aicafe.file","text":"This module contains functions for file operations.","title":"file"},{"location":"APIs/aicafe.file/#aicafe.core.file.types_tifs_avail","text":"Return a list of the types of available . tif files. Parameters: Name Type Description Default path_case str The path of the case whose available tifs need to be listed. required Returns: Name Type Description list list [ str ] A list of types. All types can be found in TYPES_TIFS .","title":"types_tifs_avail()"},{"location":"APIs/aicafe.img/","text":"module aicafe.img This module contains functions for image processing. cummul_mats ( mats ) Compute cumulative multiplications of matrixes. Parameters: Name Type Description Default mats ArrayLike Shape of [ P , N , N ] , a group of \\(N\\times N\\) matrixes. required Returns: Name Type Description mats_cum NDArray Shape of [ P , N , N ] . mats_cum [ i ] represents \\(A_iA_{i-1}\\cdots A_0\\) , where \\(A_i\\) is the matrix represented by rots [ i ] . distance ( vecs1 , vecs2 ) Compute the distances between two group of vectors. Both inputs must be able to be broadcast together. Parameters: Name Type Description Default vecs1 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., with vecs1 's shape [ A , 1 , 3 ] and vecs2 's shape [ 1 , B , 3 ] , the result's shape will be [ A , B ] . distance2d ( vecs1 , vecs2 ) Compute the distances between two group of vectors after projecting them to the x-y plane, i.e., the z coordinate will be regarded as 0. Both inputs must be able to be broadcast together. Parameters: Name Type Description Default vecs1 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., with vecs1 's shape [ A , 1 , 3 ] and vecs2 's shape [ 1 , B , 3 ] , the result's shape will be [ A , B ] . grids_polar_from_bases ( uvs , n_points_dia = 100 , n_angles = 120 ) Generate polar grids of points from 2D basis vector pairs. Specifically, let \\(u_k,v_k\\) be the \\(k\\) -th pair of basis vectors (parallel to x and y axes, respectively), \\(T\\) be the numbers of angles/diameters, and \\(R\\) be the number of points on each diameter. The origin is located at the center of the grid, so the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid ( \\(0\\leqslant i \\leqslant T-1,0\\leqslant j \\leqslant R-1\\) ) is \\[ p_{ij}^k=(i-\\frac{R-1}{2})[\\cos (\\frac{2\\pi}{T-1}j)u_k+\\sin (\\frac{2\\pi}{T-1}j)v_k] \\] The point coordinates of the resulting grids. Parameters: Name Type Description Default uvs ArrayLike Shape of [ P , 2 , 3 ] . uvs [ k - 1 , 0 ] represents \\(u_k\\) , and uvs [ k - 1 , 1 ] represents \\(v_k\\) . required n_points_dia int The number of points on each diameter. 100 n_angles int The number of angles/diameters. 120 Returns: Name Type Description grids NDArray Shape of [ P , R , T , 3 ] . grids [ k , i , j ] represents \\(p_{i,j}^k\\) , the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid. grids_rect_from_bases ( uvs , n_rows = 200 , n_cols = 200 , loc_ori = 'lower_left' ) Generate rectangular (Cartesian) grids of points from 2D basis vector pairs. Specifically, let \\(u_k,v_k\\) be the \\(k\\) -th pair of basis vectors (parallel to \\(x\\) and \\(y\\) axes, respectively), and \\(R,C\\) be the numbers of grid rows and columns, respectively, thus \\(0\\leqslant i\\leqslant R-1,0\\leqslant j\\leqslant C-1\\) . If the origin is located at the lower-left corner of the grid, i.e., loc_ori == 'lower_left' , then the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid is \\[ p_{ij}^k=ju_k+(R-i-1)v_k, \\] If the original is located at the center of the grid, i.e., loc_ori == 'center' , then \\[ p_{ij}^k=(j-\\frac{C-1}{2})u_k+(\\frac{R-1}{2}-i)v_k. \\] The point coordinates of the resulting grids with different loc_ori. Parameters: Name Type Description Default uvs ArrayLike Shape of [ P , 2 , 3 ] . uvs [ k - 1 , 0 ] represents \\(u_k\\) , and uvs [ k - 1 , 1 ] represents \\(v_k\\) . required n_rows int The number of rows of each grid. 200 n_cols int The number of columns of each grid. 200 loc_ori str 'lower_left' or 'center' . The location of the origin for each grid. 'lower_left' Returns: Name Type Description grids NDArray Shape of [ P , R , C , 3 ] . grids [ k , i , j ] represents \\(p_{i,j}^k\\) , the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid. mats_rot ( vecs1 , vecs2 ) Compute the rotation matrixes that rotate vectors in vecs1 to those in vecs2 . Specifically, let \\(x_i\\) be the \\(i\\) -th vector in vecs1 , and \\(y_i\\) be the \\(i\\) -th vector in vecs2 , and \\(R_i\\) is the \\(i\\) -th rotation matrix in the returned mats , then \\(R_i\\) is orthonormal, and \\(R_i\\frac{x_i}{\\|x_i\\|}=\\frac{y_i}{\\|y_i\\|}\\) . Parameters: Name Type Description Default vecs1 ArrayLike Shape [ P , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ P , 3 ] , an array of 3D coordinates. required Returns: Name Type Description mats NDArray Shape of [ P , 3 , 3 ] . Array of rotation matrixes, where mats [ i ] is the rotation matrix that rotates vecs1 [ i ] to vecs2 [ i ] , i.e., mats are orthonormal matrixes, and mats @ normalize ( vecs1 )[ ... , None ] == normalize ( vecs2 )[ ... , None ] . mod ( vecs ) Compute the moduli of vectors. Parameters: Name Type Description Default vecs ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Shape of [ ... ] . normalize ( vecs ) Normalize vectors to unit length. Parameters: Name Type Description Default vecs ArrayLike Shape of [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Shape of [ ... , 3 ] , the normalized vectors, i.e., the L2 norms of last dimension are 1. If a vector in vecs has length of 0, then the normalized vector will still be a zero vector. points_ori2xsec ( points , curve ) Transform given points from original image space (in which the curve is localized) to the space of stacked cross-sectional images (which are generated from points on the curve). Specifically, let the points on the curve be \\(\\{c_k\\}\\) , and \\(t_k\\) be the tangent vector of the curve at \\(c_k\\) , then \\(t_k\\) is perpendicular to the cross-sectional plane \\(\\mathcal{S}_k\\) through \\(c_k\\) . Given a point \\(p\\) to be transformed, the algorithm first determines between which two planes \\(\\mathcal{S}_k,\\mathcal{S}_{k+1}\\) it lies, by asserting that the angle between \\(\\overrightarrow{pc_k}\\) and \\(\\overrightarrow{pc_{k+1}}\\) must be obtuse. There may be multiple \\(k\\) 's satisfying this condition, and the \\(k\\) with the minimal \\(\\|c_kp\\|\\) will be selected. If there is no \\(k\\) satisfying the condition, \\(p\\) is not valid for transformation , thus will be discarded, i.e., no transformed result of \\(p\\) will be included in the return array. After determining \\(k\\) , the \\(z\\) -coordinate of transformed \\(p\\) is \\(k+1-\\lambda\\) , where \\(\\lambda(p)\\) is calculated by solving \\[ \\left\\{\\begin{array}{l} c=\\lambda c_{k}+(1-\\lambda) c_{k+1} \\\\ t=\\lambda t_{k}+(1-\\lambda) t_{k+1} \\\\ \\langle cp, t\\rangle=0 \\end{array}\\right. \\] where \\(t\\) can be regarded as the norm vector of the cross-sectional plane \\(\\mathcal{S}\\) that \\(p\\) lies in, and \\(c\\) is the intersection point of \\(\\mathcal{S}\\) and \\(c_kc_{k+1}\\) . The \\(x\\) - and \\(y\\) -coordinates of transformed \\(p\\) are calculated as the projections of \\(\\overrightarrow{cp}\\) on the two unit basis vectors \\(u,v\\) of \\(\\mathcal{S}\\) , where \\(u,v\\) are calculated using the algorithm described in aicafe.img.vecs_basis_xsec . Parameters: Name Type Description Default points ArrayLike Shape of [ P , 3 ] , 3D coordinates representing points in the original image space. These points are usually close to the curve. required curve ArrayLike Shape of [ C , 3 ] , 3D coordinates representing the points on the curve. required Returns: Type Description NDArray Shape of [ P0 , 3 ] , 3D coordinates representing points in the cross-sectional image space, each of which corresponds to a point valid for transformation in points . P0 is the number of valid points. list [ int ] Shape of P0 , indexes of points valid for transformation. points_sur_curve ( curve , box = None , rad = 3 ) Get the grid points surrounding a curve. Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. The coordinates must be non-negative. required box ArrayLike Shape of [ 3 ] , the bounding box containing the curve and the surrounding points. Note that the box always has a vertex of \\((0,0,0)\\) , thus only 3 (rather than 6) parameters are needed. If None , it will be calculated as the smallest box that contains the curve. None rad float A point is surrounding the curve if and only if there exists a point on the curve such that the distance between the two points is less than or equal to radius . 3 Returns: Type Description NDArray Shape of [ Q , 3 ] , an array of 3D coordinates representing the grid points around the curve. sample_array ( array , points , mode_interp = 'linear' , value_pad = 0 ) Sample/Interpolate values of an array at given points (locations). Usually, the array represents an image, and the points represents a multi-dimensional grid of coordinates. Specifically, an image \\(I:\\Omega\\rightarrow\\mathbb{R}^C\\) is regarded as a mapping (function) from the image space \\(\\Omega\\subset\\mathbb{R}^D\\) to the space of pixel values, that is, \\(D=2\\) or \\(3\\) for a 2D or 3D image, and \\(C=1\\) or \\(3\\) for a grayscale or RGB image. Therefore, the input array contains sampled values of the image on a regular grid, and the input points contains \\(D\\) -dimensional coordinates where the pixel values need to be interpolated. Parameters: Name Type Description Default array np . ndarray Multi-dimensional. Typically, the shape is [ B , X , Y ] or [ B , X , Y , Z ] for a batch of 2D or 3D grayscale image; [ B , 3 , X , Y ] or [ B , 3 , X , Y , Z ] for a batch of 2D or 3D RGB images. The dimension of B is not needed if only one image is interpolated. Note that for grayscale images, there should not be a dimension with size 1 before X , due to Scipy's behavior (see the Notes of Scipy for more information). required points ArrayLike Shape of [ ... , n_dims ] , where n_dims is the dimension of array . For example, if shapes of array and 'points' are [ B , X , Y ] and [ 5 , 7 , 3 ] , respectively, then points [ i , j ] == [ b = 2 , 0.3 , 0.4 ] means that the point \\(p_{ij}\\) is in the 0.3-th row and 0.4-th column of the \\(b=2\\) -nd image. required mode_interp str 'linear' or 'nearest' . The mode of interpolation. 'linear' value_pad float Interpolated value for points outside the array space \\(\\Omega\\) (domain, coverage). 0 Returns: Name Type Description values NDArray Shape of [ ... ] . Interpolated values of array at points . Examples: >>> from aicafe import img >>> img0 = [[ 0 , 1 ],[ 2 , 3 ]] # [2, 2] >>> img1 = [[ 4 , 5 ],[ 6 , 7 ]] # [2, 2] >>> array = np . stack ([ img0 , img1 ], axis = 0 ) # [B, X, Y] == [2, 2, 2] >>> # points: shape of [4, 3], where 3 == n_dims >>> points = [[ 0 , 0 , 1 ], # the first 0: interpolate img0, the second 0 and 1: interpolate at location [0, 1] ... [ 0 , 0.25 , 0.5 ], ... [ 1 , 1 , 1 ], ... [ 1 , 0.5 , 0.25 ]] >>> img . sample_array ( array , points ) >>> array ([ 1. , 1. , 7. , 5.25 ]) vecs_basis_xsec ( curve = None , tans = None , rots_cum = None ) Compute the orthonormal basis (containing two vectors) for the 2D cross-sectional plane at each point on the curve. Specifically, let the two basis vectors for the cross-sectional plane of the \\(i\\) -th point be \\(u_i\\) and \\(v_i\\) , then \\(\\|u_i\\|=\\|v_i\\|=1\\) , \\(u_i\\bot v_i\\) , and \\(u_i, v_i\\bot t_i\\) , where \\(t_i\\) is the ( \\(i\\) -th) tangent vector of the curve at the \\(i\\) -th point. For the definition of the tangent vector, see aicafe.img.vecs_tan . Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. None tans ArrayLike Shape of [ P , 3 ] , an array of 3D coordinates, each of which represents the tangent vector at a point on the curve. If curve is not None , tans will not be used, and tangent vectors will be calculated using curve . None rots_cum ArrayLike Shape of [ P , 3 , 3 ] , an array of cumulative rotation matrixes. If None , it will be calculated from tans . None Returns: Name Type Description uvs NDArray Shape of [ P , 2 , 3 ] . For \\(1\\leqslant i\\leqslant P\\) , uvs [ i - 1 , 0 ] represents \\(u_i\\) , and uvs [ i - 1 , 1 ] represents \\(v_i\\) . Raises: Type Description ValueError If curve and tans are both None . The choice of basis is deterministic. There are infinite choices for the basis of a plane, that is, the basis can be rotated along the tangent vector and still be a basis. But in this function the basis of each plane is calculated via a deterministic algorithm: Initially, we set \\(t_0=(1,0,0)^T, u_0=(0,1,0)^T,v_0=(0,0,1)^T\\) . For the first point on the curve (i.e., \\(i=1\\) ), we calculate the rotation matrix \\(R_0\\) , which rotates \\(t_0\\) to \\(t_1\\) . For definition of the rotation matrix, see aicafe.img.mats_rot . Then \\(u_1=R_0u_0,v_1=R_0v_0\\) . For the \\(i+1\\) -th ( \\(i\\geqslant1\\) ) point, let the rotation matrix that rotates \\(t_i\\) to \\(t_{i+1}\\) be \\(R_{i}\\) , then \\(u_{i+1}=R_iu_i, v_{i+1}=R_iv_i\\) . This algorithm minimizes the change in cross-sectional direction at two consecutive points. Thus, if we further use the computed basis vectors to generate the cross-sectional images along the curve for a 3D image, the continuity of two consecutive cross-sectional images will be retained to the maximum extent possible, which is essential, for example, for multiplanar reformation (MPR) views in vascular imaging. vecs_tan ( curve , normalized = False ) Get the tangent vectors at points on a curve. Specifically, let \\(t_i,1\\leqslant i\\leqslant P\\) , be the \\(i\\) -th tangent vector, and \\(v_i\\) be the \\(i\\) -th point. Then, \\(t_1=v_2-v_1,t_P=v_P-v_{P-1}\\) , and for \\(2\\leqslant i \\leqslant P-1\\) , \\(t_i=\\frac{v_{i+1}-v_i}{\\|v_{i+1}-v_i\\|}+\\frac{v_i-v_{i-1}}{\\|v_i-v_{i-1}\\|}\\) . \\(t_i\\) 's can be further normalized to unit vectors, if normalized is True . Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. required normalized bool If True , all tangent vectors are normalized to have unit length. False Returns: Name Type Description vecs NDArray Shape of [ P , 3 ] . vecs [ i , 3 ] is the 3D coordinates that represent the tangent vector at the i-th point.","title":"aicafe.img"},{"location":"APIs/aicafe.img/#aicafe.img","text":"This module contains functions for image processing.","title":"img"},{"location":"APIs/aicafe.img/#aicafe.core.img.cummul_mats","text":"Compute cumulative multiplications of matrixes. Parameters: Name Type Description Default mats ArrayLike Shape of [ P , N , N ] , a group of \\(N\\times N\\) matrixes. required Returns: Name Type Description mats_cum NDArray Shape of [ P , N , N ] . mats_cum [ i ] represents \\(A_iA_{i-1}\\cdots A_0\\) , where \\(A_i\\) is the matrix represented by rots [ i ] .","title":"cummul_mats()"},{"location":"APIs/aicafe.img/#aicafe.core.img.distance","text":"Compute the distances between two group of vectors. Both inputs must be able to be broadcast together. Parameters: Name Type Description Default vecs1 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., with vecs1 's shape [ A , 1 , 3 ] and vecs2 's shape [ 1 , B , 3 ] , the result's shape will be [ A , B ] .","title":"distance()"},{"location":"APIs/aicafe.img/#aicafe.core.img.distance2d","text":"Compute the distances between two group of vectors after projecting them to the x-y plane, i.e., the z coordinate will be regarded as 0. Both inputs must be able to be broadcast together. Parameters: Name Type Description Default vecs1 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., with vecs1 's shape [ A , 1 , 3 ] and vecs2 's shape [ 1 , B , 3 ] , the result's shape will be [ A , B ] .","title":"distance2d()"},{"location":"APIs/aicafe.img/#aicafe.core.img.grids_polar_from_bases","text":"Generate polar grids of points from 2D basis vector pairs. Specifically, let \\(u_k,v_k\\) be the \\(k\\) -th pair of basis vectors (parallel to x and y axes, respectively), \\(T\\) be the numbers of angles/diameters, and \\(R\\) be the number of points on each diameter. The origin is located at the center of the grid, so the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid ( \\(0\\leqslant i \\leqslant T-1,0\\leqslant j \\leqslant R-1\\) ) is \\[ p_{ij}^k=(i-\\frac{R-1}{2})[\\cos (\\frac{2\\pi}{T-1}j)u_k+\\sin (\\frac{2\\pi}{T-1}j)v_k] \\] The point coordinates of the resulting grids. Parameters: Name Type Description Default uvs ArrayLike Shape of [ P , 2 , 3 ] . uvs [ k - 1 , 0 ] represents \\(u_k\\) , and uvs [ k - 1 , 1 ] represents \\(v_k\\) . required n_points_dia int The number of points on each diameter. 100 n_angles int The number of angles/diameters. 120 Returns: Name Type Description grids NDArray Shape of [ P , R , T , 3 ] . grids [ k , i , j ] represents \\(p_{i,j}^k\\) , the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid.","title":"grids_polar_from_bases()"},{"location":"APIs/aicafe.img/#aicafe.core.img.grids_rect_from_bases","text":"Generate rectangular (Cartesian) grids of points from 2D basis vector pairs. Specifically, let \\(u_k,v_k\\) be the \\(k\\) -th pair of basis vectors (parallel to \\(x\\) and \\(y\\) axes, respectively), and \\(R,C\\) be the numbers of grid rows and columns, respectively, thus \\(0\\leqslant i\\leqslant R-1,0\\leqslant j\\leqslant C-1\\) . If the origin is located at the lower-left corner of the grid, i.e., loc_ori == 'lower_left' , then the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid is \\[ p_{ij}^k=ju_k+(R-i-1)v_k, \\] If the original is located at the center of the grid, i.e., loc_ori == 'center' , then \\[ p_{ij}^k=(j-\\frac{C-1}{2})u_k+(\\frac{R-1}{2}-i)v_k. \\] The point coordinates of the resulting grids with different loc_ori. Parameters: Name Type Description Default uvs ArrayLike Shape of [ P , 2 , 3 ] . uvs [ k - 1 , 0 ] represents \\(u_k\\) , and uvs [ k - 1 , 1 ] represents \\(v_k\\) . required n_rows int The number of rows of each grid. 200 n_cols int The number of columns of each grid. 200 loc_ori str 'lower_left' or 'center' . The location of the origin for each grid. 'lower_left' Returns: Name Type Description grids NDArray Shape of [ P , R , C , 3 ] . grids [ k , i , j ] represents \\(p_{i,j}^k\\) , the point in the \\(i\\) -th row and \\(j\\) -th column of the \\(k\\) -th grid.","title":"grids_rect_from_bases()"},{"location":"APIs/aicafe.img/#aicafe.core.img.mats_rot","text":"Compute the rotation matrixes that rotate vectors in vecs1 to those in vecs2 . Specifically, let \\(x_i\\) be the \\(i\\) -th vector in vecs1 , and \\(y_i\\) be the \\(i\\) -th vector in vecs2 , and \\(R_i\\) is the \\(i\\) -th rotation matrix in the returned mats , then \\(R_i\\) is orthonormal, and \\(R_i\\frac{x_i}{\\|x_i\\|}=\\frac{y_i}{\\|y_i\\|}\\) . Parameters: Name Type Description Default vecs1 ArrayLike Shape [ P , 3 ] , an array of 3D coordinates. required vecs2 ArrayLike Shape [ P , 3 ] , an array of 3D coordinates. required Returns: Name Type Description mats NDArray Shape of [ P , 3 , 3 ] . Array of rotation matrixes, where mats [ i ] is the rotation matrix that rotates vecs1 [ i ] to vecs2 [ i ] , i.e., mats are orthonormal matrixes, and mats @ normalize ( vecs1 )[ ... , None ] == normalize ( vecs2 )[ ... , None ] .","title":"mats_rot()"},{"location":"APIs/aicafe.img/#aicafe.core.img.mod","text":"Compute the moduli of vectors. Parameters: Name Type Description Default vecs ArrayLike Shape [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Shape of [ ... ] .","title":"mod()"},{"location":"APIs/aicafe.img/#aicafe.core.img.normalize","text":"Normalize vectors to unit length. Parameters: Name Type Description Default vecs ArrayLike Shape of [ ... , 3 ] , an array of 3D coordinates. required Returns: Type Description NDArray Shape of [ ... , 3 ] , the normalized vectors, i.e., the L2 norms of last dimension are 1. If a vector in vecs has length of 0, then the normalized vector will still be a zero vector.","title":"normalize()"},{"location":"APIs/aicafe.img/#aicafe.core.img.points_ori2xsec","text":"Transform given points from original image space (in which the curve is localized) to the space of stacked cross-sectional images (which are generated from points on the curve). Specifically, let the points on the curve be \\(\\{c_k\\}\\) , and \\(t_k\\) be the tangent vector of the curve at \\(c_k\\) , then \\(t_k\\) is perpendicular to the cross-sectional plane \\(\\mathcal{S}_k\\) through \\(c_k\\) . Given a point \\(p\\) to be transformed, the algorithm first determines between which two planes \\(\\mathcal{S}_k,\\mathcal{S}_{k+1}\\) it lies, by asserting that the angle between \\(\\overrightarrow{pc_k}\\) and \\(\\overrightarrow{pc_{k+1}}\\) must be obtuse. There may be multiple \\(k\\) 's satisfying this condition, and the \\(k\\) with the minimal \\(\\|c_kp\\|\\) will be selected. If there is no \\(k\\) satisfying the condition, \\(p\\) is not valid for transformation , thus will be discarded, i.e., no transformed result of \\(p\\) will be included in the return array. After determining \\(k\\) , the \\(z\\) -coordinate of transformed \\(p\\) is \\(k+1-\\lambda\\) , where \\(\\lambda(p)\\) is calculated by solving \\[ \\left\\{\\begin{array}{l} c=\\lambda c_{k}+(1-\\lambda) c_{k+1} \\\\ t=\\lambda t_{k}+(1-\\lambda) t_{k+1} \\\\ \\langle cp, t\\rangle=0 \\end{array}\\right. \\] where \\(t\\) can be regarded as the norm vector of the cross-sectional plane \\(\\mathcal{S}\\) that \\(p\\) lies in, and \\(c\\) is the intersection point of \\(\\mathcal{S}\\) and \\(c_kc_{k+1}\\) . The \\(x\\) - and \\(y\\) -coordinates of transformed \\(p\\) are calculated as the projections of \\(\\overrightarrow{cp}\\) on the two unit basis vectors \\(u,v\\) of \\(\\mathcal{S}\\) , where \\(u,v\\) are calculated using the algorithm described in aicafe.img.vecs_basis_xsec . Parameters: Name Type Description Default points ArrayLike Shape of [ P , 3 ] , 3D coordinates representing points in the original image space. These points are usually close to the curve. required curve ArrayLike Shape of [ C , 3 ] , 3D coordinates representing the points on the curve. required Returns: Type Description NDArray Shape of [ P0 , 3 ] , 3D coordinates representing points in the cross-sectional image space, each of which corresponds to a point valid for transformation in points . P0 is the number of valid points. list [ int ] Shape of P0 , indexes of points valid for transformation.","title":"points_ori2xsec()"},{"location":"APIs/aicafe.img/#aicafe.core.img.points_sur_curve","text":"Get the grid points surrounding a curve. Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. The coordinates must be non-negative. required box ArrayLike Shape of [ 3 ] , the bounding box containing the curve and the surrounding points. Note that the box always has a vertex of \\((0,0,0)\\) , thus only 3 (rather than 6) parameters are needed. If None , it will be calculated as the smallest box that contains the curve. None rad float A point is surrounding the curve if and only if there exists a point on the curve such that the distance between the two points is less than or equal to radius . 3 Returns: Type Description NDArray Shape of [ Q , 3 ] , an array of 3D coordinates representing the grid points around the curve.","title":"points_sur_curve()"},{"location":"APIs/aicafe.img/#aicafe.core.img.sample_array","text":"Sample/Interpolate values of an array at given points (locations). Usually, the array represents an image, and the points represents a multi-dimensional grid of coordinates. Specifically, an image \\(I:\\Omega\\rightarrow\\mathbb{R}^C\\) is regarded as a mapping (function) from the image space \\(\\Omega\\subset\\mathbb{R}^D\\) to the space of pixel values, that is, \\(D=2\\) or \\(3\\) for a 2D or 3D image, and \\(C=1\\) or \\(3\\) for a grayscale or RGB image. Therefore, the input array contains sampled values of the image on a regular grid, and the input points contains \\(D\\) -dimensional coordinates where the pixel values need to be interpolated. Parameters: Name Type Description Default array np . ndarray Multi-dimensional. Typically, the shape is [ B , X , Y ] or [ B , X , Y , Z ] for a batch of 2D or 3D grayscale image; [ B , 3 , X , Y ] or [ B , 3 , X , Y , Z ] for a batch of 2D or 3D RGB images. The dimension of B is not needed if only one image is interpolated. Note that for grayscale images, there should not be a dimension with size 1 before X , due to Scipy's behavior (see the Notes of Scipy for more information). required points ArrayLike Shape of [ ... , n_dims ] , where n_dims is the dimension of array . For example, if shapes of array and 'points' are [ B , X , Y ] and [ 5 , 7 , 3 ] , respectively, then points [ i , j ] == [ b = 2 , 0.3 , 0.4 ] means that the point \\(p_{ij}\\) is in the 0.3-th row and 0.4-th column of the \\(b=2\\) -nd image. required mode_interp str 'linear' or 'nearest' . The mode of interpolation. 'linear' value_pad float Interpolated value for points outside the array space \\(\\Omega\\) (domain, coverage). 0 Returns: Name Type Description values NDArray Shape of [ ... ] . Interpolated values of array at points . Examples: >>> from aicafe import img >>> img0 = [[ 0 , 1 ],[ 2 , 3 ]] # [2, 2] >>> img1 = [[ 4 , 5 ],[ 6 , 7 ]] # [2, 2] >>> array = np . stack ([ img0 , img1 ], axis = 0 ) # [B, X, Y] == [2, 2, 2] >>> # points: shape of [4, 3], where 3 == n_dims >>> points = [[ 0 , 0 , 1 ], # the first 0: interpolate img0, the second 0 and 1: interpolate at location [0, 1] ... [ 0 , 0.25 , 0.5 ], ... [ 1 , 1 , 1 ], ... [ 1 , 0.5 , 0.25 ]] >>> img . sample_array ( array , points ) >>> array ([ 1. , 1. , 7. , 5.25 ])","title":"sample_array()"},{"location":"APIs/aicafe.img/#aicafe.core.img.vecs_basis_xsec","text":"Compute the orthonormal basis (containing two vectors) for the 2D cross-sectional plane at each point on the curve. Specifically, let the two basis vectors for the cross-sectional plane of the \\(i\\) -th point be \\(u_i\\) and \\(v_i\\) , then \\(\\|u_i\\|=\\|v_i\\|=1\\) , \\(u_i\\bot v_i\\) , and \\(u_i, v_i\\bot t_i\\) , where \\(t_i\\) is the ( \\(i\\) -th) tangent vector of the curve at the \\(i\\) -th point. For the definition of the tangent vector, see aicafe.img.vecs_tan . Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. None tans ArrayLike Shape of [ P , 3 ] , an array of 3D coordinates, each of which represents the tangent vector at a point on the curve. If curve is not None , tans will not be used, and tangent vectors will be calculated using curve . None rots_cum ArrayLike Shape of [ P , 3 , 3 ] , an array of cumulative rotation matrixes. If None , it will be calculated from tans . None Returns: Name Type Description uvs NDArray Shape of [ P , 2 , 3 ] . For \\(1\\leqslant i\\leqslant P\\) , uvs [ i - 1 , 0 ] represents \\(u_i\\) , and uvs [ i - 1 , 1 ] represents \\(v_i\\) . Raises: Type Description ValueError If curve and tans are both None . The choice of basis is deterministic. There are infinite choices for the basis of a plane, that is, the basis can be rotated along the tangent vector and still be a basis. But in this function the basis of each plane is calculated via a deterministic algorithm: Initially, we set \\(t_0=(1,0,0)^T, u_0=(0,1,0)^T,v_0=(0,0,1)^T\\) . For the first point on the curve (i.e., \\(i=1\\) ), we calculate the rotation matrix \\(R_0\\) , which rotates \\(t_0\\) to \\(t_1\\) . For definition of the rotation matrix, see aicafe.img.mats_rot . Then \\(u_1=R_0u_0,v_1=R_0v_0\\) . For the \\(i+1\\) -th ( \\(i\\geqslant1\\) ) point, let the rotation matrix that rotates \\(t_i\\) to \\(t_{i+1}\\) be \\(R_{i}\\) , then \\(u_{i+1}=R_iu_i, v_{i+1}=R_iv_i\\) . This algorithm minimizes the change in cross-sectional direction at two consecutive points. Thus, if we further use the computed basis vectors to generate the cross-sectional images along the curve for a 3D image, the continuity of two consecutive cross-sectional images will be retained to the maximum extent possible, which is essential, for example, for multiplanar reformation (MPR) views in vascular imaging.","title":"vecs_basis_xsec()"},{"location":"APIs/aicafe.img/#aicafe.core.img.vecs_tan","text":"Get the tangent vectors at points on a curve. Specifically, let \\(t_i,1\\leqslant i\\leqslant P\\) , be the \\(i\\) -th tangent vector, and \\(v_i\\) be the \\(i\\) -th point. Then, \\(t_1=v_2-v_1,t_P=v_P-v_{P-1}\\) , and for \\(2\\leqslant i \\leqslant P-1\\) , \\(t_i=\\frac{v_{i+1}-v_i}{\\|v_{i+1}-v_i\\|}+\\frac{v_i-v_{i-1}}{\\|v_i-v_{i-1}\\|}\\) . \\(t_i\\) 's can be further normalized to unit vectors, if normalized is True . Parameters: Name Type Description Default curve ArrayLike Shape of [ P , 3 ] ( \\(P\\geqslant 2\\) ), an array of 3D coordinates representing the points on the curve. required normalized bool If True , all tangent vectors are normalized to have unit length. False Returns: Name Type Description vecs NDArray Shape of [ P , 3 ] . vecs [ i , 3 ] is the 3D coordinates that represent the tangent vector at the i-th point.","title":"vecs_tan()"},{"location":"APIs/elements/aicafe.PointSet/","text":"class aicafe.PointSet ( np . ndarray ) This class represents a set of coordinates (points) in a 3D space. The points are supposed to be arranged regularly to form a grid. It is a subclass of Numpy 's ndarray , and thus supports all Numpy functions, methods, and attributes, but also has some additional methods and attributes. To initialize a point set, see __new__ () below. By default, its shape is [ ... , 3 ] , where [ 3 ] indicates the dimension, and [ ... ] indicates the shape of the grid, such as [ 10 ] or [ 3 , 5 ] . For example, a PointSet instance with shape of [ 2 , 4 , 3 ] contains the coordinates of 3D points located on a \\(2\\times4\\) grid. __new__ ( cls , array ) To initialize a point set, simply generate an ArrayLike data structure, and then pass it to __new__ . No __init__ method is needed because the point set is fully initialized after the __new__ method. Examples: You can initialize a point set using numpy array: >>> array = np . array (( 1 , 2 , 3 )) >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ]]) or using a list: >>> array = [[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]] >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) The shape of input must be or can be reshaped to [ ... , 3 ] . For example, you can input a 1-D list with length of 6 to get a point set with shape of [ 2 , 3 ] : >>> array = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Keep the last dimension equal to 3 There is no restriction on changing the last dimension from 3 to any other number. However, all methods and properties of a point set are designed to work only when the last dimension is 3. Therefore, if you want to apply some numpy function or operation to a point set and expect the result is still a valid instance of PointSet , take care to make sure that the result still has shape of [ ... , 3 ] . Returns: Type Description PointSet [ float ] Initialized point set. Raises: Type Description ValueError If array cannot be reshaped to [ ... , 3 ] . angle ( self , p , unit = 'radian' ) Compute the angle of self and p. Both must be able to be broadcast together. Parameters: Name Type Description Default p NDArray Shape [ ... , 3 ] , array of 3D coordinates. required unit str The unit of the result, 'radian' or 'degree' . 'radian' Returns: Type Description np . ndarray Array with broadcast shape. E.g., when self's shape is [ A , 1 , 3 ] and p's shape is [ 1 , B , 3 ] , the result's shape will be [ A , B ] . Raises: Type Description NotImplementedError If unit is not 'radian' or 'degree' . distance ( self , p ) Compute the distances from self to p. See aicafe.img.distance for full documentation. distance2d ( self , p ) Compute the distance from self to p in the x-y plane, i.e., the z coordinate will be regarded as 0. See aicafe.img.distance2d for full documentation. id_float ( self ) ndarray [ str ] , shape [ ... ] . The id of self, represented by point coordinates ( % .3 f ). Examples: >>> p = ac . PointSet ([[ 1 , 2 , 3 ], [ 1.1 , 2.2 , 3.3 ]]) >>> p . ids_float [ '1.000_2.000_3.000' '1.100_2.200_3.300' ] id_int ( self ) ndarray [ str ] , shape [ ... ] . The id of self, represented by point coordinates ( int ). Examples: >>> p = ac . PointSet ([[ 1 , 2 , 3 ], [ 1.1 , 2.6 , 3.3 ]]) >>> p . ids_int [ '1_2_3' '1_2_3' ] in_box ( self , box , allowance = 0 ) Determine if self is in a bounding box. Parameters: Name Type Description Default box 'ArrayLike' [ x_min , y_min , z_min , x_max , y_max , z_max ] or its reshaped version with shape of [ 2 , 3 ] . required allowance coordinate Distance allowed for self to leave the box. 0 Returns: Type Description ndarray [ bool ] Shape [ ... ] . An element is True if the corresponding point belongs to the closed 3D cube \\([x_{\\min}-a, x_{\\max}+a]\\times [y_{\\min}-a, y_{\\max}+a]\\times [z_{\\min}-a, z_{\\max}+a]\\subset\\mathbb{R}^3\\) , where \\(a\\) is the allowance . Raises: Type Description ValueError If box can not be reshaped to [ 2 , 3 ] . in_img ( self , shape ) Determine if self is in an image's coverage. Parameters: Name Type Description Default shape Sequence [ coordinate ] Image shape; must be 3D. required Returns: Type Description NDArray ndarray[bool]: Shape [ ... ] . An element is True if the corresponding point belongs to the closed 3D tube \\([0, x-1]\\times[0, y-1]\\times[0, z-1]\\) , where \\([x, y, z]\\) is the image shape, e.g., \\([512, 512, 320]\\) . Raises: Type Description ValueError If image shape is not 3D. mod ( self ) The moduli of vectors from the origin \\((0, 0, 0)\\) to the points in self. See aicafe.img.mod for the function with the same name. Returns: Type Description NDArray Shape of [ ... ] . n_points ( self ) The number of points in self. normalize ( self ) Normalized self. See aicafe.img.normalize for full documentation. product ( self , p ) Compute the dot product of self and p. Both must be able to be broadcast together. Parameters: Name Type Description Default p NDArray Shape [..., 3], array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., when self's shape is [ A , 1 , 3 ] and p's shape is [ 1 , B , 3 ] , the result's shape will be [ A , B ] . round ( self , decimals = 0 ) Return a point set with each element rounded to the given number of decimals. Parameters: Name Type Description Default decimals int Number of decimal places to round to. If it is negative, it specifies the number of positions to the left of the decimal point. 0 Returns: Type Description 'PointSet' Its each point equals to the corresponding point in self after np.round(decimals).","title":"aicafe.PointSet"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.PointSet","text":"This class represents a set of coordinates (points) in a 3D space. The points are supposed to be arranged regularly to form a grid. It is a subclass of Numpy 's ndarray , and thus supports all Numpy functions, methods, and attributes, but also has some additional methods and attributes. To initialize a point set, see __new__ () below. By default, its shape is [ ... , 3 ] , where [ 3 ] indicates the dimension, and [ ... ] indicates the shape of the grid, such as [ 10 ] or [ 3 , 5 ] . For example, a PointSet instance with shape of [ 2 , 4 , 3 ] contains the coordinates of 3D points located on a \\(2\\times4\\) grid.","title":"PointSet"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.__new__","text":"To initialize a point set, simply generate an ArrayLike data structure, and then pass it to __new__ . No __init__ method is needed because the point set is fully initialized after the __new__ method. Examples: You can initialize a point set using numpy array: >>> array = np . array (( 1 , 2 , 3 )) >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ]]) or using a list: >>> array = [[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]] >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) The shape of input must be or can be reshaped to [ ... , 3 ] . For example, you can input a 1-D list with length of 6 to get a point set with shape of [ 2 , 3 ] : >>> array = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> ac . PointSet ( array ) PointSet ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) Keep the last dimension equal to 3 There is no restriction on changing the last dimension from 3 to any other number. However, all methods and properties of a point set are designed to work only when the last dimension is 3. Therefore, if you want to apply some numpy function or operation to a point set and expect the result is still a valid instance of PointSet , take care to make sure that the result still has shape of [ ... , 3 ] . Returns: Type Description PointSet [ float ] Initialized point set. Raises: Type Description ValueError If array cannot be reshaped to [ ... , 3 ] .","title":"__new__()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.angle","text":"Compute the angle of self and p. Both must be able to be broadcast together. Parameters: Name Type Description Default p NDArray Shape [ ... , 3 ] , array of 3D coordinates. required unit str The unit of the result, 'radian' or 'degree' . 'radian' Returns: Type Description np . ndarray Array with broadcast shape. E.g., when self's shape is [ A , 1 , 3 ] and p's shape is [ 1 , B , 3 ] , the result's shape will be [ A , B ] . Raises: Type Description NotImplementedError If unit is not 'radian' or 'degree' .","title":"angle()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.distance","text":"Compute the distances from self to p. See aicafe.img.distance for full documentation.","title":"distance()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.distance2d","text":"Compute the distance from self to p in the x-y plane, i.e., the z coordinate will be regarded as 0. See aicafe.img.distance2d for full documentation.","title":"distance2d()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.id_float","text":"ndarray [ str ] , shape [ ... ] . The id of self, represented by point coordinates ( % .3 f ). Examples: >>> p = ac . PointSet ([[ 1 , 2 , 3 ], [ 1.1 , 2.2 , 3.3 ]]) >>> p . ids_float [ '1.000_2.000_3.000' '1.100_2.200_3.300' ]","title":"id_float()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.id_int","text":"ndarray [ str ] , shape [ ... ] . The id of self, represented by point coordinates ( int ). Examples: >>> p = ac . PointSet ([[ 1 , 2 , 3 ], [ 1.1 , 2.6 , 3.3 ]]) >>> p . ids_int [ '1_2_3' '1_2_3' ]","title":"id_int()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.in_box","text":"Determine if self is in a bounding box. Parameters: Name Type Description Default box 'ArrayLike' [ x_min , y_min , z_min , x_max , y_max , z_max ] or its reshaped version with shape of [ 2 , 3 ] . required allowance coordinate Distance allowed for self to leave the box. 0 Returns: Type Description ndarray [ bool ] Shape [ ... ] . An element is True if the corresponding point belongs to the closed 3D cube \\([x_{\\min}-a, x_{\\max}+a]\\times [y_{\\min}-a, y_{\\max}+a]\\times [z_{\\min}-a, z_{\\max}+a]\\subset\\mathbb{R}^3\\) , where \\(a\\) is the allowance . Raises: Type Description ValueError If box can not be reshaped to [ 2 , 3 ] .","title":"in_box()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.in_img","text":"Determine if self is in an image's coverage. Parameters: Name Type Description Default shape Sequence [ coordinate ] Image shape; must be 3D. required Returns: Type Description NDArray ndarray[bool]: Shape [ ... ] . An element is True if the corresponding point belongs to the closed 3D tube \\([0, x-1]\\times[0, y-1]\\times[0, z-1]\\) , where \\([x, y, z]\\) is the image shape, e.g., \\([512, 512, 320]\\) . Raises: Type Description ValueError If image shape is not 3D.","title":"in_img()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.mod","text":"The moduli of vectors from the origin \\((0, 0, 0)\\) to the points in self. See aicafe.img.mod for the function with the same name. Returns: Type Description NDArray Shape of [ ... ] .","title":"mod()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.n_points","text":"The number of points in self.","title":"n_points()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.normalize","text":"Normalized self. See aicafe.img.normalize for full documentation.","title":"normalize()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.product","text":"Compute the dot product of self and p. Both must be able to be broadcast together. Parameters: Name Type Description Default p NDArray Shape [..., 3], array of 3D coordinates. required Returns: Type Description NDArray Array with broadcast shape. E.g., when self's shape is [ A , 1 , 3 ] and p's shape is [ 1 , B , 3 ] , the result's shape will be [ A , B ] .","title":"product()"},{"location":"APIs/elements/aicafe.PointSet/#aicafe.core.elements.point_set.PointSet.round","text":"Return a point set with each element rounded to the given number of decimals. Parameters: Name Type Description Default decimals int Number of decimal places to round to. If it is negative, it specifies the number of positions to the left of the decimal point. 0 Returns: Type Description 'PointSet' Its each point equals to the corresponding point in self after np.round(decimals).","title":"round()"},{"location":"APIs/elements/aicafe.Snake/","text":"class aicafe.Snake ( PointSet ) This class represents a curve in a 3D space. The curve is constituted by a series of sequentially connected points, and is thus named a snake . A snake can have some additional attributes for the whole point set (e.g., snake type) or for each point (e.g., radius at each point). Snake is a subclass of PointSet . While a point set consists of points on a regular grid, Snake forces the points to have a 1D shape, i.e., the point set representing a snake should have a shape of [ P , 3 ] , where [ P ] indicates the number of points in the snake. To initialize a snake, see __new__ () below. __new__ ( cls , array , type = None , radii = None ) To initialize a snake, simply generate a point set or an ArrayLike data structure that can initialize a point set, then pass it to Snake () . Parameters: Name Type Description Default array ArrayLike A point set to initialize the snake, or an array to initialize the point set that represents the snake. required type int The snake type represented by an integer. If None , 0 will be the type. See TYPES_SNAKES for the correspondence between integers and the actual snake types. None radii Sequence [ float ] The radii of points in the snake. If None , the radii are regarded as unknown. None Returns: Type Description Snake Initialized snake. Raises: Type Description ValueError If array cannot be used to initialize a point set, or the initialized point set's shape is not [ P , 3 ] , or the number of values in radii does not match the number of points in self. length ( self ) Length of self. Returns: Type Description float The sum of distances between every two consecutive points on the curve. Examples: >>> ac . Snake ([[ 0 , 0 , 1 ], [ 0 , 1 , 0 ], [ 1 , 0 , 1 ]]) . length # 2 * np.sqrt(2) 3.1462643 lengths_cum ( self ) Cumulative lengths of self. Returns: Type Description NDArray Shape of [P], where \\(P\\) is the number of points on self. The \\(i\\) -th element is the length of the curve consisting of the first \\(i\\) points on self. Particularly, the \\(0\\) -th element is \\(0\\) . resample ( self , step = None ) Resample points on the curve so that the points are equidistant. The first and last points will be the same. Parameters: Name Type Description Default step the fixed distance between two consecutive points after resampling. None Return (Snake): The resampled snake. The radius at each point will also be interpolated if not None .","title":"aicafe.Snake"},{"location":"APIs/elements/aicafe.Snake/#aicafe.Snake","text":"This class represents a curve in a 3D space. The curve is constituted by a series of sequentially connected points, and is thus named a snake . A snake can have some additional attributes for the whole point set (e.g., snake type) or for each point (e.g., radius at each point). Snake is a subclass of PointSet . While a point set consists of points on a regular grid, Snake forces the points to have a 1D shape, i.e., the point set representing a snake should have a shape of [ P , 3 ] , where [ P ] indicates the number of points in the snake. To initialize a snake, see __new__ () below.","title":"Snake"},{"location":"APIs/elements/aicafe.Snake/#aicafe.core.elements.snake.Snake.__new__","text":"To initialize a snake, simply generate a point set or an ArrayLike data structure that can initialize a point set, then pass it to Snake () . Parameters: Name Type Description Default array ArrayLike A point set to initialize the snake, or an array to initialize the point set that represents the snake. required type int The snake type represented by an integer. If None , 0 will be the type. See TYPES_SNAKES for the correspondence between integers and the actual snake types. None radii Sequence [ float ] The radii of points in the snake. If None , the radii are regarded as unknown. None Returns: Type Description Snake Initialized snake. Raises: Type Description ValueError If array cannot be used to initialize a point set, or the initialized point set's shape is not [ P , 3 ] , or the number of values in radii does not match the number of points in self.","title":"__new__()"},{"location":"APIs/elements/aicafe.Snake/#aicafe.core.elements.snake.Snake.length","text":"Length of self. Returns: Type Description float The sum of distances between every two consecutive points on the curve. Examples: >>> ac . Snake ([[ 0 , 0 , 1 ], [ 0 , 1 , 0 ], [ 1 , 0 , 1 ]]) . length # 2 * np.sqrt(2) 3.1462643","title":"length()"},{"location":"APIs/elements/aicafe.Snake/#aicafe.core.elements.snake.Snake.lengths_cum","text":"Cumulative lengths of self. Returns: Type Description NDArray Shape of [P], where \\(P\\) is the number of points on self. The \\(i\\) -th element is the length of the curve consisting of the first \\(i\\) points on self. Particularly, the \\(0\\) -th element is \\(0\\) .","title":"lengths_cum()"},{"location":"APIs/elements/aicafe.Snake/#aicafe.core.elements.snake.Snake.resample","text":"Resample points on the curve so that the points are equidistant. The first and last points will be the same. Parameters: Name Type Description Default step the fixed distance between two consecutive points after resampling. None Return (Snake): The resampled snake. The radius at each point will also be interpolated if not None .","title":"resample()"},{"location":"APIs/elements/aicafe.SnakeSet/","text":"class aicafe.SnakeSet This class represents a set of snakes . To initialize a snake set, see __init__ () below. __init__ ( self , snakes , types = None ) Initialize a snake set. Parameters: Name Type Description Default snakes Sequence [ ArrayLike ] Each array is used to initialize one snake, so it must satisfy the requirements for initializing a snake , see __new__ () of Snake for more information. required types Sequence [ int ] The types of snakes represented by integers. Only used when values in snakes are ArrayLike. None lengths ( self , idxs = None ) Lengths of some snakes in self. Parameters: Name Type Description Default idxs Sequence [ int ] List of integer indexes of snakes. If None , the lengths of all snakes will be calculated. None Returns: Type Description list [ float ] The lengths of designated snakes. Examples: >>> # 3 snakes >>> ss = ac . SnakeSet ([[[ 0 , 0 , 0 ], [ 1 , 0 , 0 ]], ... [[ 2 , 0 , 0 ], [ 4 , 0 , 0 ]], ... [[ 6 , 0 , 0 ], [ 9 , 0 , 0 ]]]) >>> ss . lengths () [ 1.0 , 2.0 , 3.0 ] >>> ss . lengths ([ 2 , 0 ]) [ 3.0 , 1.0 ] n_snakes ( self ) The number of snakes. Can also get it using len ( self ) . types ( self ) Types of snakes, represented by integers, as defined in TYPES_SNAKES .","title":"aicafe.SnakeSet"},{"location":"APIs/elements/aicafe.SnakeSet/#aicafe.SnakeSet","text":"This class represents a set of snakes . To initialize a snake set, see __init__ () below.","title":"SnakeSet"},{"location":"APIs/elements/aicafe.SnakeSet/#aicafe.core.elements.snake_set.SnakeSet.__init__","text":"Initialize a snake set. Parameters: Name Type Description Default snakes Sequence [ ArrayLike ] Each array is used to initialize one snake, so it must satisfy the requirements for initializing a snake , see __new__ () of Snake for more information. required types Sequence [ int ] The types of snakes represented by integers. Only used when values in snakes are ArrayLike. None","title":"__init__()"},{"location":"APIs/elements/aicafe.SnakeSet/#aicafe.core.elements.snake_set.SnakeSet.lengths","text":"Lengths of some snakes in self. Parameters: Name Type Description Default idxs Sequence [ int ] List of integer indexes of snakes. If None , the lengths of all snakes will be calculated. None Returns: Type Description list [ float ] The lengths of designated snakes. Examples: >>> # 3 snakes >>> ss = ac . SnakeSet ([[[ 0 , 0 , 0 ], [ 1 , 0 , 0 ]], ... [[ 2 , 0 , 0 ], [ 4 , 0 , 0 ]], ... [[ 6 , 0 , 0 ], [ 9 , 0 , 0 ]]]) >>> ss . lengths () [ 1.0 , 2.0 , 3.0 ] >>> ss . lengths ([ 2 , 0 ]) [ 3.0 , 1.0 ]","title":"lengths()"},{"location":"APIs/elements/aicafe.SnakeSet/#aicafe.core.elements.snake_set.SnakeSet.n_snakes","text":"The number of snakes. Can also get it using len ( self ) .","title":"n_snakes()"},{"location":"APIs/elements/aicafe.SnakeSet/#aicafe.core.elements.snake_set.SnakeSet.types","text":"Types of snakes, represented by integers, as defined in TYPES_SNAKES .","title":"types()"},{"location":"APIs/elements/aicafe.xml/","text":"module aicafe.xml Classes class XML This class manipulates the xml file for a case. The xml file is named setting_TH_0_xxx_U . xml in the case folder 0 _xxx_U , and contains information about resolutions, landmarks, rigid transformation matrices of sequences, etc. __init__ ( self , path ) Initialize an xml. Parameters: Name Type Description Default path str Path to the xml file of a case. required get_rtms ( self , names_seqs = None ) Get a dict mapping a sequence name to the rigid transformation matrix for the xml tree of self. See aicafe.xml.get_rtms for more information. get_rtms ( root = None , names_seqs = None ) Get a dict mapping a sequence name to the rigid transformation matrix. Parameters: Name Type Description Default root Union [ str , XML , Element ] The root element of an xml tree. If it is a str , it will be regarded as a path to an xml file, whose root element will be used; if it is an aicafe . XML instance, its attribute root will be used; if it is an xml Element instance, itself will be used. None names_seqs Union [ str , list [ str ]] The names of sequences whose rigid transformation matrices need to be retrieved. If it is a str , it will be regarded as the name of the only sequence; if it is a list of str , each string will be regarded as a sequence name; if None , the rigid transformation matrices of all sequences contained in the xml tree of root will be retrieved. None Returns: Name Type Description name2rtm dict [ str , NDArray ] Sequence name -> matrix. The matrix \\(A=[R, t]\\) has shape of [ 3 , 4 ] , where \\(R\\) is the \\(3\\times3\\) rotation matrix and \\(t\\) is a \\(3\\times1\\) column vector of the translation, such that \\([x^\\prime,y^\\prime,z^\\prime]^T=A[x,y,z,1]^T\\) is the transformed vector.","title":"aicafe.xml"},{"location":"APIs/elements/aicafe.xml/#aicafe.xml","text":"","title":"xml"},{"location":"APIs/elements/aicafe.xml/#aicafe.xml-classes","text":"","title":"Classes"},{"location":"APIs/elements/aicafe.xml/#aicafe.core.elements.xml.XML","text":"This class manipulates the xml file for a case. The xml file is named setting_TH_0_xxx_U . xml in the case folder 0 _xxx_U , and contains information about resolutions, landmarks, rigid transformation matrices of sequences, etc. __init__ ( self , path ) Initialize an xml. Parameters: Name Type Description Default path str Path to the xml file of a case. required get_rtms ( self , names_seqs = None ) Get a dict mapping a sequence name to the rigid transformation matrix for the xml tree of self. See aicafe.xml.get_rtms for more information.","title":"XML"},{"location":"APIs/elements/aicafe.xml/#aicafe.core.elements.xml.get_rtms","text":"Get a dict mapping a sequence name to the rigid transformation matrix. Parameters: Name Type Description Default root Union [ str , XML , Element ] The root element of an xml tree. If it is a str , it will be regarded as a path to an xml file, whose root element will be used; if it is an aicafe . XML instance, its attribute root will be used; if it is an xml Element instance, itself will be used. None names_seqs Union [ str , list [ str ]] The names of sequences whose rigid transformation matrices need to be retrieved. If it is a str , it will be regarded as the name of the only sequence; if it is a list of str , each string will be regarded as a sequence name; if None , the rigid transformation matrices of all sequences contained in the xml tree of root will be retrieved. None Returns: Name Type Description name2rtm dict [ str , NDArray ] Sequence name -> matrix. The matrix \\(A=[R, t]\\) has shape of [ 3 , 4 ] , where \\(R\\) is the \\(3\\times3\\) rotation matrix and \\(t\\) is a \\(3\\times1\\) column vector of the translation, such that \\([x^\\prime,y^\\prime,z^\\prime]^T=A[x,y,z,1]^T\\) is the transformed vector.","title":"get_rtms()"},{"location":"APIs/workflow/aicafe.Case/","text":"class aicafe.Case The class for a case in a dataset. Most of the procedure of processing the data of a case is done in this class. Attributes: Name Type Description path str The path of the case, i.e., the input of __init__ () . name_case str The name of the case, normally like 0 _XX_U according to iCafe's naming convention. 0 denotes the age ( 0 for unknown age), 'XX' denotes the id, and U denotes the gender ( M , F , or U for unknown gender) name_dataset str The name of the dataset that the case belongs to, e.g., CROP . __init__ ( self , path ) init . Parameters: Name Type Description Default path str The path of the case to process, e.g., iCafe / results / CROP / 0 _XX_U . required Raises: Type Description FileNotFoundError If input path does not exists or is not a directory.","title":"aicafe.Case"},{"location":"APIs/workflow/aicafe.Case/#aicafe.Case","text":"The class for a case in a dataset. Most of the procedure of processing the data of a case is done in this class. Attributes: Name Type Description path str The path of the case, i.e., the input of __init__ () . name_case str The name of the case, normally like 0 _XX_U according to iCafe's naming convention. 0 denotes the age ( 0 for unknown age), 'XX' denotes the id, and U denotes the gender ( M , F , or U for unknown gender) name_dataset str The name of the dataset that the case belongs to, e.g., CROP .","title":"Case"},{"location":"APIs/workflow/aicafe.Case/#aicafe.workflow.case.Case.__init__","text":"init . Parameters: Name Type Description Default path str The path of the case to process, e.g., iCafe / results / CROP / 0 _XX_U . required Raises: Type Description FileNotFoundError If input path does not exists or is not a directory.","title":"__init__()"},{"location":"APIs/workflow/aicafe.mpr/","text":"module aicafe.mpr Classes class MPR This class handles image and file operations related to the multiplanar reformation (MPR) views.","title":"aicafe.mpr"},{"location":"APIs/workflow/aicafe.mpr/#aicafe.mpr","text":"","title":"mpr"},{"location":"APIs/workflow/aicafe.mpr/#aicafe.mpr-classes","text":"","title":"Classes"},{"location":"APIs/workflow/aicafe.mpr/#aicafe.workflow.mpr.MPR","text":"This class handles image and file operations related to the multiplanar reformation (MPR) views.","title":"MPR"},{"location":"User%20Guide/","text":"Introduction","title":"Introduction"},{"location":"User%20Guide/#introduction","text":"","title":"Introduction"},{"location":"User%20Guide/Basic%20Usage/","text":"Load data Initialize a case Herein, assume the following directory structure: 1 2 3 4 . \u2514\u2500\u2500 CROP \u251c\u2500\u2500 0_XXX_U \u2514\u2500\u2500 0_YYY_U where CROP is the dataset name, and 0 _XXX_U and 0 _YYY_U are folders of two cases, normally containing those . tif and other files. The goal is to process the case 0 _XXX_U using AICafe. Firstly, you need to initialize the class aicafe.Case for the case you want to process. 1 2 3 import aicafe as ac case = ac . Case ( path = './0_XXX_U' ) The new version (since 1.0) of AICafe has a \"lazy loading\" strategy, i.e. it usually does not require the user to manually load the image files in the case folder, but will automatically read them when a method needs it. Check file structure You can print some attributes of the instance of Case to check if the file structure is correct, for example, 1 2 3 4 5 6 7 8 # path of the case print ( case . path ) # name of the case print ( case . name_case ) # name of the dataset print ( case . name_dataset ) # types of all available tif files in the case folder print ( case . types_tifs_avail ) All attributes can be found in the class aicafe.Case . Vessel tree","title":"Basic Usage"},{"location":"User%20Guide/Basic%20Usage/#load-data","text":"","title":"Load data"},{"location":"User%20Guide/Basic%20Usage/#initialize-a-case","text":"Herein, assume the following directory structure: 1 2 3 4 . \u2514\u2500\u2500 CROP \u251c\u2500\u2500 0_XXX_U \u2514\u2500\u2500 0_YYY_U where CROP is the dataset name, and 0 _XXX_U and 0 _YYY_U are folders of two cases, normally containing those . tif and other files. The goal is to process the case 0 _XXX_U using AICafe. Firstly, you need to initialize the class aicafe.Case for the case you want to process. 1 2 3 import aicafe as ac case = ac . Case ( path = './0_XXX_U' ) The new version (since 1.0) of AICafe has a \"lazy loading\" strategy, i.e. it usually does not require the user to manually load the image files in the case folder, but will automatically read them when a method needs it.","title":"Initialize a case"},{"location":"User%20Guide/Basic%20Usage/#check-file-structure","text":"You can print some attributes of the instance of Case to check if the file structure is correct, for example, 1 2 3 4 5 6 7 8 # path of the case print ( case . path ) # name of the case print ( case . name_case ) # name of the dataset print ( case . name_dataset ) # types of all available tif files in the case folder print ( case . types_tifs_avail ) All attributes can be found in the class aicafe.Case .","title":"Check file structure"},{"location":"User%20Guide/Basic%20Usage/#vessel-tree","text":"","title":"Vessel tree"}]}